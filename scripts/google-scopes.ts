#!/usr/bin/env bun run
/**
 * Collect all OAuth 2.0 scopes from Google's Discovery API using Effect.
 *
 * Run:
 *   - bun run scripts/collect-google-scopes.ts
 *   - bun run scripts/collect-google-scopes.ts --include-oidc
 *   - bun run scripts/collect-google-scopes.ts --all-versions
 *
 * Output:
 *   - JSON array of scopes to stdout
 *   - Copy-pasteable TS const to stderr
 */

import { FileSystem, HttpClient, Path } from '@effect/platform';
import { BunFileSystem, BunPath, BunRuntime } from '@effect/platform-bun';
import { NodeHttpClient } from '@effect/platform-node';
import { Console, Duration, Effect, Layer, Schedule } from 'effect';

/** Types mirroring Google's Discovery endpoints */
type DiscoveryListItem = {
  name: string;
  version: string;
  discoveryRestUrl: string;
  preferred?: boolean;
};

type DiscoveryListResponse = {
  items?: DiscoveryListItem[];
};

type DiscoveryDoc = {
  auth?: {
    oauth2?: {
      scopes?: Record<string, { description?: string }>;
    };
  };
  name?: string;
  version?: string;
};

/** Constants */
const DISCOVERY_LIST_URL =
  'https://www.googleapis.com/discovery/v1/apis?preferred=true';

const DISCOVERY_LIST_ALL_VERSIONS_URL =
  'https://www.googleapis.com/discovery/v1/apis';

const OIDC_SCOPES = ['openid', 'email', 'profile'] as const;

const HEADER = `/** 
 * Auto-generated by scripts/google-scopes
 * Source: Google Discovery API
 * Do not edit by hand.
 */
`;
const OUTPUT_DIR = 'src/generated';
const OUTPUT_FILE = 'google-scopes.ts';

/** Small args helper (supports both Bun and Node) */
const readArgs = () =>
  Effect.sync(() => {
    // Bun exposes process.argv; OK to rely on it here
    const args = new Set(process.argv.slice(2));
    return {
      includeOidc: args.has('--include-oidc'),
      allVersions: args.has('--all-versions'),
    };
  });

/** Retry policy: fast exponential backoff with jitter, capped */
const makeRetryPolicy = Schedule.exponential(Duration.millis(150)).pipe(
  Schedule.jittered,
  Schedule.upTo(Duration.seconds(2)),
);

/** GET and decode JSON using Effect HttpClient with timeout + retries */
const getJson = <T>(url: string, headers?: Record<string, string>) =>
  Effect.gen(function* () {
    const res = yield* HttpClient.get(url, {
      headers: {
        'user-agent':
          'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 ' +
          '(KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36',
        accept: 'application/json',
        ...headers,
      },
    });

    if (res.status < 200 || res.status >= 300) {
      return yield* Effect.fail(
        new Error(`HTTP ${res.status} ${res.text} for ${url}`),
      );
    }

    const body = (yield* res.json) as unknown as T;
    return body;
  }).pipe(
    Effect.timeoutFail({
      duration: Duration.seconds(30),
      onTimeout: () => new Error(`Timeout after 30s for ${url}`),
    }),
    Effect.retry(makeRetryPolicy),
  );

/** List discovery APIs (preferred or all versions) */
const listApis = (allVersions: boolean) =>
  Effect.gen(function* () {
    const url = allVersions
      ? DISCOVERY_LIST_ALL_VERSIONS_URL
      : DISCOVERY_LIST_URL;

    const data = yield* getJson<DiscoveryListResponse>(url);
    return data.items ?? [];
  });

/** Extract OAuth scopes from a single discovery document */
const extractScopesFromDoc = (doc: DiscoveryDoc): string[] => {
  const scopesObj = doc.auth?.oauth2?.scopes ?? {};
  return Object.keys(scopesObj);
};

/** Fetch a single discovery doc and return its scopes; warn on error */
const fetchDocScopes = (url: string) =>
  getJson<DiscoveryDoc>(url).pipe(
    Effect.map(extractScopesFromDoc),
    Effect.catchAll((err) =>
      Console.warn(
        `Warn: Failed to fetch discovery doc ${url}: ${String(err)}`,
      ).pipe(Effect.as([] as string[])),
    ),
  );

/** Main program */
const program = Effect.gen(function* () {
  const { includeOidc, allVersions } = yield* readArgs();

  const apis = yield* listApis(allVersions);

  if (apis.length === 0) {
    yield* Console.error('No APIs returned by the Discovery directory.');
    return yield* Effect.fail(new Error('Empty discovery directory.'));
  }

  const urls = apis
    .map((a) => a.discoveryRestUrl)
    .filter((u): u is string => Boolean(u));

  // Fetch docs with modest concurrency and collect all scopes
  const scopesPerDoc = yield* Effect.forEach(urls, (u) => fetchDocScopes(u), {
    concurrency: 15,
  });

  const scopeSet = new Set(scopesPerDoc.flat());

  if (includeOidc) {
    for (const s of OIDC_SCOPES) scopeSet.add(s);
  }
  const scopes = Array.from(scopeSet).sort((a, b) => a.localeCompare(b));
  const output = `${HEADER}
export const GOOGLE_OAUTH_SCOPES = ${JSON.stringify(scopes, null, 2)} as const;
  `;

  const fs = yield* FileSystem.FileSystem;
  const path = yield* Path.Path;

  const filePath = path.join(OUTPUT_DIR, OUTPUT_FILE);
  yield* fs.writeFileString(filePath, output);
  yield* Console.log(
    `âœ” Wrote ${filePath} ${scopes.length} Google OAuth2 scopes.`,
  );
});

/** Layer: HTTP client (Node adapter works under Bun) */
const layer = Layer.mergeAll(
  NodeHttpClient.layer,
  BunFileSystem.layer,
  BunPath.layer,
);

/** Run */
program.pipe(Effect.provide(layer), BunRuntime.runMain);
