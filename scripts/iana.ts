import { FileSystem, HttpClient, Path } from '@effect/platform';
import { BunFileSystem, BunPath, BunRuntime } from '@effect/platform-bun';
import { NodeHttpClient } from '@effect/platform-node';
import { Console, Duration, Effect, Layer, Schedule } from 'effect';

/** Top-level IANA media type categories */
const TOP_LEVELS = [
  'application',
  'audio',
  'font',
  'image',
  'message',
  'model',
  'multipart',
  'text',
  'video',
] as const;

const OUTPUT_DIR = 'src/generated';
const OUTPUT_FILE = 'iana-media-types.ts';

const HEADER = `/** 
 * Auto-generated by scripts/iana.ts
 * Source: IANA Media Types registry https://www.iana.org/assignments/media-types/media-types.xhtml
 * Do not edit by hand.
 */

`;

const makeRetryPolicy = Schedule.exponential(Duration.millis(150)).pipe(
  Schedule.jittered,
  Schedule.upTo(Duration.seconds(2)),
);

/** Very simple CSV to first-column-only parser */
function parseCsvFirstColumn(text: string): string[] {
  const lines = text.split(/\r?\n/);
  if (lines.length <= 1) return [];
  const noHeader = lines.slice(1);
  const subs = new Set<string>();
  for (const line of noHeader) {
    if (!line) continue;
    const cell = line.split(',')[0]?.trim();
    if (cell) subs.add(cell);
  }
  return [...subs];
}

/** GET and decode text using Effect HttpClient */
const getText = (url: string) =>
  Effect.gen(function* () {
    const res = yield* HttpClient.get(url);
    if (res.status < 200 || res.status >= 300) {
      return yield* Effect.fail(new Error(`HTTP ${res.status} for ${url}`));
    }
    const body = (yield* res.text) as string;
    return body;
  }).pipe(Effect.retry(makeRetryPolicy));

/** Try to fetch a registry for a given top-level type via CSV. */
const fetchType = (type: string) => {
  const csvUrl = `https://www.iana.org/assignments/media-types/${type}.csv`;

  const fromCsv = getText(csvUrl).pipe(
    Effect.map((text) => parseCsvFirstColumn(text)),
  );

  return fromCsv.pipe(
    Effect.catchAll((err) =>
      Console.warn(
        `Failed to fetch registry for "${type}": ${String(err)}`,
      ).pipe(Effect.as([] as string[])),
    ),
  );
};

/** Formatters for the generated TS file */
function formatArray(name: string, items: string[]) {
  const body = items
    .slice()
    .sort((a, b) => a.localeCompare(b))
    .map((s) => JSON.stringify(s))
    .join(',\n  ');
  return `export const ${name} = [
  ${body}
] as const;
`;
}

function formatCombined(all: string[]) {
  const body = all
    .slice()
    .sort((a, b) => a.localeCompare(b))
    .map((s) => JSON.stringify(s))
    .join(',\n  ');
  return `export const IANA_MEDIA_TYPES = [
  ${body}
] as const;

export type IanaMediaType = (typeof IANA_MEDIA_TYPES)[number];
`;
}

/** Main program */
const program = Effect.gen(function* () {
  // Fetch all in parallel with modest concurrency
  const entries = yield* Effect.forEach(
    TOP_LEVELS,
    (t) =>
      fetchType(t).pipe(
        Effect.map((subs) => [t, subs.map((s) => `${t}/${s}`)] as const),
      ),
    { concurrency: 5 },
  );

  const perType = Object.fromEntries(entries) as Record<string, string[]>;

  // Build file content
  const parts: string[] = [];
  for (const t of TOP_LEVELS) {
    const varName = `IANA_${t.toUpperCase()}_TYPES`;
    parts.push(formatArray(varName, perType[t] ?? []));
  }

  const combined = formatCombined(
    Object.values(perType).flatMap((x) => x ?? []),
  );

  const out = HEADER + parts.join('\n') + '\n' + combined;

  // Write output
  const path = yield* Path.Path;
  const fs = yield* FileSystem.FileSystem;
  const dir = path.join(OUTPUT_DIR);
  yield* fs.makeDirectory(dir, { recursive: true });
  const filePath = path.join(OUTPUT_DIR, OUTPUT_FILE);
  yield* fs.writeFileString(filePath, out);

  yield* Console.log(
    `âœ” Wrote ${filePath} with IANA media types (${TOP_LEVELS.length} top-levels).`,
  );
});

const layer = Layer.mergeAll(
  NodeHttpClient.layer,
  BunFileSystem.layer,
  BunPath.layer,
);

/** Run */
program.pipe(Effect.provide(layer), BunRuntime.runMain);
